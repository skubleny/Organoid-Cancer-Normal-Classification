---
title: 'Cancer/Normal: Data Setup'
output: html_document
date: "2025-05-28"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Github Repo: https://github.com/skubleny/Organoid-Cancer-Normal-Classification/tree/main

#Libraries
```{r}
library(caret)
library(FSQN)
library(glmnet)
library(measures)
library(pROC)
```
```{r}
Libraries <- c('matrixStats', 'ruv', 'NanoStringNorm', 'data.table','NormqPCR',
               'ComplexHeatmap','dplyr', 'plotrix', 'tuple', 'scales', 'ggplot2')
lapply(Libraries, require, character.only = TRUE)
rm(Libraries)

```

#RUV cancer/normal together FFPE https://github.com/skubleny/Organoid-Cancer-Normal-Classification/tree/main
```{r}
#***** Reading Nanostring gene expression raw data from github repo 
urlfile<-'https://raw.githubusercontent.com/skubleny/Organoid-Cancer-Normal-Classification/main/Data/run1-7.txt'

Nano_ExpressionMatrix <-read.delim(urlfile,stringsAsFactors = FALSE, header = TRUE, as.is = TRUE)

#***** Reading sample and clinical information
urlfile<-'https://raw.githubusercontent.com/skubleny/Organoid-Cancer-Normal-Classification/main/Data/nanostring_samples_final.txt'
Nano_SampleInfo <-read.delim(urlfile,stringsAsFactors = FALSE, header = TRUE, as.is = TRUE)
Nano_SampleInfo = Nano_SampleInfo[c(1:84),]

dim(Nano_SampleInfo) # 24 12
table(Nano_SampleInfo$Tissues)

#Exclude poor samples
exclude = Nano_SampleInfo$exclude=="TRUE" 
Nano_SampleInfo = Nano_SampleInfo[!(Nano_SampleInfo$exclude=="TRUE"),] 
Nano_SampleInfo = dplyr::select(Nano_SampleInfo, -"exclusion_reason")


Nano_RawCounts = dplyr::filter(Nano_ExpressionMatrix,subtype=="TCGA"| subtype=="TME"  | subtype=="Negative" | subtype=="Positive"| subtype=="Housekeeping")

#***** Expression matrix
Nano_RawCounts <- as.matrix(Nano_RawCounts[ , 5:ncol(Nano_RawCounts)])
exclude = colnames(Nano_RawCounts[,exclude])
Nano_RawCounts = Nano_RawCounts[ , !(colnames(Nano_RawCounts) %in% exclude)]



#Exclude organoids OR FFPE OR Cancer OR normal
exclude = Nano_SampleInfo$sample_type=="organoid"
exclude = colnames(Nano_RawCounts[,exclude])
Nano_RawCounts = Nano_RawCounts[ , !(colnames(Nano_RawCounts) %in% exclude)]
Nano_SampleInfo = Nano_SampleInfo[!(Nano_SampleInfo$sample_type=="organoid"),] 

row.names(Nano_RawCounts) <- Nano_ExpressionMatrix[Nano_ExpressionMatrix$subtype=="TCGA" | Nano_ExpressionMatrix$subtype=="TME" | Nano_ExpressionMatrix$subtype=="Negative" |Nano_ExpressionMatrix$subtype=="Positive" |Nano_ExpressionMatrix$subtype=="Housekeeping" ,]$Probe.Name
Nano_SampleInfo$SampleNames <- colnames(Nano_RawCounts)


##################################################################################################################################
##################################################################  Exploratory  data analysis – raw counts #####################
#***** Colors for each cartridges
Color_Batches <- c('purple','orange','darkred','blue','chartreuse',
                   'darkgoldenrod4','tan2','darkgreen','red3','darkmagenta',
                   'deeppink','violet','navy','red','dodgerblue')

#***** box plot of raw data - Endogenous genes only
RawCounts_log <- log2(Nano_RawCounts[1:107 , ]+1) # Excluding 7 housekeeping genes and Nanostring spike-ins
par(mar = c(6.5,6.5,2.3,0), mgp = c(3.7 , 1 , 0))
boxplot(RawCounts_log, las = 1, cex.axis = 2, ylab = '' , xlab = '', cex.lab = 4,
        xaxt = 'n', yaxt = 'n', main = 'Unnormalized counts', cex.main = 3.5,
        outline = FALSE, names = FALSE, frame = FALSE,
        whisklty = 3, whisklwd = 1.5, staplelty = 1, notch = TRUE, boxlwd = 2,
        staplelwd = 0 , boxcol = Color_Batches[factor(Nano_SampleInfo$Cartridges)],
        border = Color_Batches[factor(Nano_SampleInfo$cartridge)] , col='gray87')
box(lwd = 7, bty = 'l')
axis(1, cex.axis=1, at = c(1, seq(20,166,20)), cex.axis = 2.5, lwd.ticks = 4, mgp = c(3.5,1.6,0))
axis(2, at = c(0, seq(3,15,3)), mgp = c(3.5,.9,0), lwd.ticks = 4, las = 1, cex.axis=3)
mtext(expression(paste('Samples', '(', 'n'[samples], '=', '162', ')')), 1, line = 4.5, cex = 2.5)
mtext(expression(paste(Log[2],' (raw counts)')), 2, line = 3.5, cex = 2.7)


#***** RLE plot - Unormalized
par(mar = c(6.5,6.5,2.3,0))
boxplot(RawCounts_log - rowMedians(RawCounts_log),
        main = '', xlab = '', ylab = '', xaxt = 'n', yaxt = 'n', ylim = c(-4.1,4.1),
        outline = FALSE, names = FALSE, frame = FALSE, whisklty = 3, whisklwd = 1.5, staplelty = 1, notch = TRUE, boxlwd = 2,
        staplelwd = 0 , boxcol = Color_Batches[factor(Nano_SampleInfo$cartridge)],
        border = Color_Batches[factor(Nano_SampleInfo$cartridge)], col = 'gray87')
box(lwd = 7, bty = 'l')
title('Unnormalized counts', line = -2, cex.main = 3.5)
Median_RawData <- apply(RawCounts_log - rowMedians(RawCounts_log), 2, median)
points(c(1:ncol(RawCounts_log)), Median_RawData, col = Color_Batches[factor(Nano_SampleInfo$cartridge)], pch = 19, cex = 1.2)
axis(2, mgp = c(3.5, .9 ,0), lwd.ticks=6, las=1, cex.axis=3)
mtext('RLE', 2, line = 3.5, cex = 3.5)
abline(h = 0, col = 'black', lwd = 5, lty = 2)
par(lwd = 3)
legend(160, 4.1, legend = c(1,2,3,'.','.','.', 13,14,15),
       col = c(Color_Batches[1:3], rep('white', 3), Color_Batches[13:15]),
       pch = 19, bty = 'n', cex = 1.4)
text(x = 162, y = 4.2 ,labels  = 'Cartridges', cex = 1.5)
rm(Median_RawData)


#####LONG 
counts = RawCounts_log - rowMedians(RawCounts_log)
counts = as.data.frame(t(counts))
counts$ID <- seq.int(nrow(counts))
counts$batchid = Nano_SampleInfo$cartridge

counts_long <- tidyr::gather(counts, gene, measurement, ABCB6:ZCCHC24, factor_key=TRUE)
counts_long$ID = as.factor(counts_long$ID)
counts_long$batchid = as.factor(counts_long$batchid)

unnormalized_counts_FFPE = ggplot(counts_long, aes(x=ID, y=measurement, fill=batchid)) + 
    geom_boxplot(notch=TRUE, outlier.size = 0.5) +
    geom_hline(yintercept=0, size =1.5, alpha=0.7) +
    ggtitle("Unnormalized Counts FFPE Nanostring Genes") +
    xlab("Sample") + 
    ylab("Relative Log2 Expression") +
    scale_y_continuous(limits=c(-7,7) , breaks = c(-6,-3, 0,3,6))+
    theme_classic()  + 
    theme(axis.text.x = element_blank()) +
    theme(axis.text.y = element_text(colour="black",size = 13)) + 
    theme(plot.title = element_text(face="plain", colour="black", size=13,hjust = 0)) +
    theme(axis.title.x = element_text(colour="black", size =13)) +
    theme(axis.title.y = element_text(colour="black", size=13)) +
    theme(legend.position = "none")

ggsave("unnormalized_counts_FFPE.svg", unnormalized_counts_FFPE, width=6, height=3)


#***** Average plot
### Average of Nanostring positive spike-ins controls
Mean_NegativeControlProbes <- apply(Nano_RawCounts[115:122, ], 2, mean)
### Average of Nanostring positive spike-ins controls
Mean_PositiveControlProbes <- apply(Nano_RawCounts[123:128, ], 2, mean)
### Average of housekeeping genes
Mean_HousekeepingGenes <- apply(Nano_RawCounts[108:114, ], 2, mean)
### Library size
LibrarySize <- colSums(Nano_RawCounts [ 1:128, ])

#### Average plots -  Supplementary Figure 2
par(mar = c(6,7,0,0))
plot(log2(LibrarySize), ylim = c(0,22), bty = 'l', typ = 'n', ylab = '', xlab = '', xaxt = 'n', yaxt = 'n')
axis(1, cex.axis = 1, at = c(1, seq(20,166,20)), cex.axis = 2, lwd.ticks = 4, mgp = c(3.5,1.4,0))
axis(2, cex.axis = 1, cex.axis = 2, lwd.ticks = 4, mgp = c(3.5,1,0), las = 1)
mtext(expression(paste(Log [2], ' (raw counts)')), 2, line = 3.5, cex = 3)
mtext(expression(paste('Samples', ' (', 'n'[samples], '=', '21', ')')), 1, line = 4.5, cex = 2.5)
X <- c(0,6,18,30,42,53,65,77,89,101,113,125,137,143,155,167)
GradiantColors <- paste0('gray', seq(90,20, by = -5))
for(i in 1:15) rect(X[i],-5, X[i+1], 22, col = GradiantColors[i], lty = 0 )
points(log2(LibrarySize), col = alpha('darkgoldenrod1', .8), pch = 15, cex = 1.8, lwd = 1.5)
lines(smooth.spline(c(1:length(LibrarySize)), log2(LibrarySize), df = 5), col = 'darkgoldenrod1', lwd = 4)
points(log2(Mean_HousekeepingGenes) + 3, cex = 2, col = alpha('red', .6), pch = 19)
lines(smooth.spline(c(1:length(LibrarySize)), log2(Mean_HousekeepingGenes) + 3, df = 5), col = 'red', lwd = 4)
points(log2(Mean_PositiveControlProbes) - 1, col = alpha('cyan2', .8), pch = 18, cex = 2.5)
lines(smooth.spline(c(1:length(LibrarySize)), log2(Mean_PositiveControlProbes) - 1, df = 5), col = 'cyan1', lwd = 4)
points(log2(Mean_NegativeControlProbes), col = alpha('green2', .6), pch = 17, cex = 1.8)
lines(smooth.spline(c(1:length(LibrarySize)), log2(Mean_NegativeControlProbes), df = 5), col = 'green2', lwd = 4)
box(lwd = 5, bty = 'l')
rm(X, GradiantColors, Mean_NegativeControlProbes,
   Mean_PositiveControlProbes, Mean_HousekeepingGenes,
   LibrarySize)


#***** Log ratio between all pairs of duplicated samples
DuplicatedSamples <- tuplicate(Nano_SampleInfo$Patient.barcodes, 2)
length(DuplicatedSamples) 

LogRatio_TechRep_RawCounts <- vector()
for(i in 1:1){
  index <- Nano_SampleInfo$Patient.barcodes == DuplicatedSamples[i]
  RepData <- RawCounts_log [ , index]
  LogRatio <- as.data.frame(RepData[ , 1] - RepData[ , 2] )
  colnames(LogRatio) <- 'LogRatio'
  LogRatio$Replicates <- rep( i , 107)
  LogRatio_TechRep_RawCounts <- rbind(LogRatio_TechRep_RawCounts , LogRatio)
  rm(i, index, RepData, LogRatio)
}
nrow(LogRatio_TechRep_RawCounts)/107 # 17
LogRatio_TechRep_RawCounts$Datasets <- 'Unnormalized'




##################################################################################################################################
############################################### RUV-III normalization - using technical replicates and control genes #############

#***** Creating replicate matrix
length(Nano_SampleInfo$Patient.barcodes) # 53
length(unique(Nano_SampleInfo$Patient.barcodes)) # 43

ReplicateMatrix <- ruv::replicate.matrix(Nano_SampleInfo$Patient.barcodes)
dim(ReplicateMatrix) # 53 43

### Making sure that every row has got only one number
par(mfrow = c(2,1))
barplot(colSums(ReplicateMatrix))
barplot(rowSums(ReplicateMatrix))
par(mfrow = c(1,1))


#***** Finding control genes
### Step 1: Using all genes as a set of negative control genes
# Performing RUVIII
dataRUV <- t(log2(Nano_RawCounts[1:107, ] + 1))
RUVcorrected <- ruv::RUVIII(Y = dataRUV, M = ReplicateMatrix, ctl = c(1:107))
RUVcorrected <- t(RUVcorrected)

### Step 2: Selecting the most stable genes from step 1
LowVarGenes <- apply(RUVcorrected, 1, var)
ControlGenes <- which(LowVarGenes < .5)
length(ControlGenes) # 59 genes


### Step3: Performing RUV-III using the ControlGenes set
RUVcorrected <- RUVIII(Y = dataRUV, M = ReplicateMatrix, ctl = ControlGenes, k = 7)
RUVcorrected <- t(RUVcorrected)
dim(RUVcorrected)
# We tried different numbers of k based on our positive controls####
all(colnames(RUVcorrected) == Nano_SampleInfo$SampleNames) ## TRUE


#***** RLE plots - Figure 1 A, RUV-III normalization
par(mar = c(6.5,6.5,2.3,0))
boxplot(RUVcorrected - rowMedians(RUVcorrected), main = '', xlab = '', ylab = '', xaxt = 'n', yaxt = 'n', ylim = c(-4.1,4.1),
        outline = FALSE, names = FALSE, frame = FALSE, whisklty = 3, whisklwd = 1.5, staplelty = 1, notch = TRUE, boxlwd = 2,
        staplelwd = 0 , boxcol = Color_Batches[factor(Nano_SampleInfo$cartridge)],
        border = Color_Batches[factor(Nano_SampleInfo$cartridge)], col = 'gray87')
box(lwd = 7, bty = 'l')
title('RUV-III normalized', line = -2, cex.main = 3.5)
Median_RUV <- apply(RUVcorrected - rowMedians(RUVcorrected), 2, median)
points(c(1:ncol(RUVcorrected)), Median_RUV, col = Color_Batches[factor(Nano_SampleInfo$cartridge)], pch = 19, cex = 1.2)
axis(1, cex.axis = 1, at = c(1, seq(20,166,20)), cex.axis = 2.5, lwd.ticks = 6,  mgp = c(3.5,1.6,0))
axis(2, mgp = c(3.5,.9,0), lwd.ticks = 6, las = 1, cex.axis = 3)
mtext(expression(paste('Samples','(', 'n'[samples], '=', '162', ')')),1 ,line = 5, cex = 3)
mtext('RLE', 2, line = 3.5, cex = 3.5)
abline(h = 0, col = 'black', lwd = 5, lty = 2)


#####LONG 
counts = RUVcorrected - rowMedians(RUVcorrected)
counts = as.data.frame(t(counts))
counts$ID <- seq.int(nrow(counts))
counts$batchid = Nano_SampleInfo$cartridge

counts_long <- tidyr::gather(counts, gene, measurement, ABCB6:ZCCHC24, factor_key=TRUE)
counts_long$ID = as.factor(counts_long$ID)
counts_long$batchid = as.factor(counts_long$batchid)

normalized_counts_ffpe = ggplot(counts_long, aes(x=ID, y=measurement, fill=batchid)) + 
    geom_boxplot(notch=TRUE, outlier.size = 0.5) +
    geom_hline(yintercept=0, size =1.5, alpha=0.7) +
    ggtitle("RUV-III Normalized Counts FFPE Nanostring Genes") +
    xlab("Sample") + 
    ylab("Relative Log2 Expression") +
    scale_y_continuous(limits=c(-7,7) , breaks = c(-6,-3, 0,3,6))+
    theme_classic()  + 
    theme(axis.text.x = element_blank()) +
    theme(axis.text.y = element_text(colour="black",size = 13)) + 
    theme(plot.title = element_text(face="plain", colour="black", size=13,hjust = 0)) +
    theme(axis.title.x = element_text(colour="black", size =13)) +
    theme(axis.title.y = element_text(colour="black", size=13)) +
    theme(legend.position = "none")

ggsave("normalized_counts_ffpe.svg", normalized_counts_ffpe, width=6, height=3)


#***** Log DIFFERENCE between technical duplicated - per the paper
### Assessing the perfromance of RUV-III using 'leave out one duplicate'
DuplicatedSamples <- tuplicate(Nano_SampleInfo$Patient.barcodes, 2)
length(DuplicatedSamples) # 17
LogRatio_TechRep_RUVIII <- vector()
dataRUV <- t(log2(Nano_RawCounts[1:107, ] +1))

for(l in 1:length(DuplicatedSamples)){
  index <- Nano_SampleInfo$Patient.barcodes == DuplicatedSamples[l]
  info <- Nano_SampleInfo
  info$Patient.barcodes[index] <- c('Rep1', 'Rep2')
  X <- length(info$Patient.barcodes)
  Y <- length(unique(info$Patient.barcodes))
  
  ReplicateMatrix <- matrix(0, nrow = X, ncol = Y)
  row.names(ReplicateMatrix) <- info$Patient.barcodes
  colnames(ReplicateMatrix) <- unique(info$Patient.barcodes)
  for(i in 1:Y){
    n <- colnames(ReplicateMatrix)[i]
    sa <- which(row.names(ReplicateMatrix)==n)
    for(j in 1:length(sa)){
      ReplicateMatrix [sa[j] , i] <- 1
    }
  }
  RUVcorrected_Data <- ruv::RUVIII(dataRUV , ReplicateMatrix , ctl = ControlGenes, k = 2)
  RUVcorrected_Data <- t(RUVcorrected_Data)
  index <- which(index)
  LogRatio <- as.data.frame( (RUVcorrected_Data[ , index[1]] ) - (RUVcorrected_Data[ , index[2]]) )
  colnames(LogRatio) <- 'LogRatio'
  LogRatio$Replicates <- rep(l , 107)
  LogRatio_TechRep_RUVIII <- rbind(LogRatio_TechRep_RUVIII , LogRatio)
  rm(i, index, info, X, Y, LogRatio)
  
}
nrow(LogRatio_TechRep_RUVIII)/107
LogRatio_TechRep_RUVIII$Datasets <- 'RUV-III normalized'


#***** Technical Replicate Agreement plot for unnormalized, Nanostring Normalization and RUV-III (leave out one technical replicate)
### Figure
TRAallNormalizations <- rbind(LogRatio_TechRep_RawCounts, LogRatio_TechRep_RUVIII)
TRAallNormalizations$Replicates <- as.factor(TRAallNormalizations$Replicates)
TRAallNormalizations$Datasets <- as.factor(TRAallNormalizations$Datasets)
TRAallNormalizations$Datasets  <- factor(TRAallNormalizations$Datasets , levels = c('Unnormalized','RUV-III normalized'))
ggplot(data = TRAallNormalizations) +
  geom_boxplot(aes(y = LogRatio, x = Replicates, fill = Datasets, color=Datasets), outlier.size = .5,
               position = position_dodge(width = .7),
               width = 1, alpha = 0.8, lwd = .7) +
  ylab('Log ratio')+ylim(c(-10,10)) +
  scale_color_manual(values = c('lightblue', 'royalblue', 'navy')) +
  scale_fill_manual(values = c('lightblue', 'royalblue', 'navy')) +
  theme_classic() +
  geom_hline(yintercept = 0, lty = 2, lwd = .6, col = 'red')+
  theme(axis.title = element_text(size = 25),
        axis.text.x = element_text(size = 20),
        axis.text.y = element_text(size = 20),
        axis.line = element_line(size = 1.5),
        legend.title = element_text(size = 20, face = c('italic', 'bold')),
        legend.text = element_text(size = 20),
        legend.position = "top", legend.direction = "horizontal")


#***** Log RATIO between technical duplicated - the paper incorrectly called the log difference the ratio 
### Assessing the perfromance of RUV-III using 'leave out one duplicate'
DuplicatedSamples <- tuplicate(Nano_SampleInfo$Patient.barcodes, 2)
length(DuplicatedSamples) 
LogRatio_TechRep_RUVIII <- vector()
dataRUV <- t(log2(Nano_RawCounts[1:107, ] +1))

for(l in 1:length(DuplicatedSamples)){
  index <- Nano_SampleInfo$Patient.barcodes == DuplicatedSamples[l]
  info <- Nano_SampleInfo
  info$Patient.barcodes[index] <- c('Rep1', 'Rep2')
  X <- length(info$Patient.barcodes)
  Y <- length(unique(info$Patient.barcodes))
  
  ReplicateMatrix <- matrix(0, nrow = X, ncol = Y)
  row.names(ReplicateMatrix) <- info$Patient.barcodes
  colnames(ReplicateMatrix) <- unique(info$Patient.barcodes)
  for(i in 1:Y){
    n <- colnames(ReplicateMatrix)[i]
    sa <- which(row.names(ReplicateMatrix)==n)
    for(j in 1:length(sa)){
      ReplicateMatrix [sa[j] , i] <- 1
    }
  }
  RUVcorrected_Data <- ruv::RUVIII(dataRUV , ReplicateMatrix , ctl = ControlGenes, k = 2)
  RUVcorrected_Data <- t(RUVcorrected_Data)
  index <- which(index)
  LogRatio <- as.data.frame( (RUVcorrected_Data[ , index[1]] ) / (RUVcorrected_Data[ , index[2]]))
  colnames(LogRatio) <- 'LogRatio'
  LogRatio$Replicates <- rep(l , 107)
  LogRatio_TechRep_RUVIII <- rbind(LogRatio_TechRep_RUVIII , LogRatio)
  rm(i, index, info, X, Y, LogRatio)
  
}
nrow(LogRatio_TechRep_RUVIII)/107
LogRatio_TechRep_RUVIII$Datasets <- 'RUV-III normalized'


#***** Technical Replicate Agreement plot for unnormalized, Nanostring Normalization and RUV-III (leave out one technical replicate)
### Figure 
TRAallNormalizations <- rbind(LogRatio_TechRep_RawCounts, LogRatio_TechRep_RUVIII)
TRAallNormalizations$Replicates <- as.factor(TRAallNormalizations$Replicates)
TRAallNormalizations$Datasets <- as.factor(TRAallNormalizations$Datasets)
TRAallNormalizations$Datasets  <- factor(TRAallNormalizations$Datasets , levels = c('Unnormalized','RUV-III normalized'))
ggplot(data = TRAallNormalizations) +
  geom_boxplot(aes(y = LogRatio, x = Replicates, fill = Datasets, color=Datasets), outlier.size = .5,
               position = position_dodge(width = .7),
               width = 1, alpha = 0.8, lwd = .7) +
  ylab('Log ratio')+ylim(c(-10,10)) +
  scale_color_manual(values = c('lightblue', 'royalblue', 'navy')) +
  scale_fill_manual(values = c('lightblue', 'royalblue', 'navy')) +
  theme_classic() +
  geom_hline(yintercept = 1, lty = 2, lwd = .6, col = 'red')+
  theme(axis.title = element_text(size = 25),
        axis.text.x = element_text(size = 20),
        axis.text.y = element_text(size = 20),
        axis.line = element_line(size = 1.5),
        legend.title = element_text(size = 20, face = c('italic', 'bold')),
        legend.text = element_text(size = 20),
        legend.position = "top", legend.direction = "horizontal")

############################################FINAL NORMALIZATION###################################################
length(Nano_SampleInfo$Patient.barcodes) 
length(unique(Nano_SampleInfo$Patient.barcodes))

ReplicateMatrix <- ruv::replicate.matrix(Nano_SampleInfo$Patient.barcodes)
dim(ReplicateMatrix) 
#***** Finding control genes
### Step 1: Using all genes as a set of negative control genes
# Performing RUVIII
dataRUV <- t(log2(Nano_RawCounts[1:107, ] +1))
RUVcorrected <- ruv::RUVIII(Y = dataRUV, M = ReplicateMatrix, ctl = c(1:107))
RUVcorrected <- t(RUVcorrected)

### Step 2: Selecting the most stable genes from step 1
LowVarGenes <- apply(RUVcorrected, 1, var)
ControlGenes <- which(LowVarGenes < .5)
length(ControlGenes) # 15 genes


### Step3: Performing RUV-III using the ControlGenes set
RUVcorrected <- RUVIII(Y = dataRUV, M = ReplicateMatrix, ctl = ControlGenes, k = 7)
RUVcorrected <- t(RUVcorrected)
dim(RUVcorrected)
# We tried different numbers of k based on our positive controls
all(colnames(RUVcorrected) == Nano_SampleInfo$SampleNames) ## TRUE

RUVcorrected_all = RUVcorrected
```

#Heatmap
```{r}
#normalized together ffpe
common_nanostring = RUVcorrected_all
pheatmap(common_nanostring)

common_nanostring = t(common_nanostring)
common_nanostring = as.data.frame(common_nanostring)

names = Nano_SampleInfo
names = dplyr::select(names, c("Patient.barcodes","SampleNames"))

common_nanostring = tibble::rownames_to_column(common_nanostring, "sample_id")


normcancer_ffpe = merge(common_nanostring, names, by.x="sample_id", by.y="SampleNames")
normcancer_ffpe = normcancer_ffpe[,-1]
colnames(normcancer_ffpe)[which(names(normcancer_ffpe) == "Patient.barcodes")] <- "sample_id"



normcancer_ffpe %>% group_by(sample_id) %>% summarise_all(mean) %>% data.frame() -> normcancer_ffpe
normcancer_ffpe = tibble::column_to_rownames(normcancer_ffpe, "sample_id")
pheatmap(normcancer_ffpe)

colnames(normcancer_ffpe) = gsub("\\.", "-", colnames(normcancer_ffpe))

```
#RUV cancer/normal together organoid
```{r}
#***** Reading Nanostring gene expression raw data from github repo 
urlfile<-'https://raw.githubusercontent.com/skubleny/Organoid-Cancer-Normal-Classification/main/Data/run1-7.txt'

Nano_ExpressionMatrix <-read.delim(urlfile,stringsAsFactors = FALSE, header = TRUE, as.is = TRUE)


#***** Reading sample and clinical information
urlfile<-'https://raw.githubusercontent.com/skubleny/Organoid-Cancer-Normal-Classification/main/Data/nanostring_samples_final.txt'
Nano_SampleInfo <-read.delim(urlfile,stringsAsFactors = FALSE, header = TRUE, as.is = TRUE)
Nano_SampleInfo = Nano_SampleInfo[c(1:84),]

dim(Nano_SampleInfo) # 24 12
table(Nano_SampleInfo$Tissues)

#Exclude poor samples
exclude = Nano_SampleInfo$exclude=="TRUE" 
Nano_SampleInfo = Nano_SampleInfo[!(Nano_SampleInfo$exclude=="TRUE"),] 
Nano_SampleInfo = dplyr::select(Nano_SampleInfo, -"exclusion_reason")


Nano_RawCounts = dplyr::filter(Nano_ExpressionMatrix, subtype=="TCGA"| subtype=="TME"  | subtype=="Negative" | subtype=="Positive"| subtype=="Housekeeping")

#***** Expression matrix
Nano_RawCounts <- as.matrix(Nano_RawCounts[ , 5:ncol(Nano_RawCounts)])
exclude = colnames(Nano_RawCounts[,exclude])
Nano_RawCounts = Nano_RawCounts[ , !(colnames(Nano_RawCounts) %in% exclude)]



#Exclude organoids OR FFPE OR Cancer OR normal
exclude = Nano_SampleInfo$sample_type=="FFPE"
exclude = colnames(Nano_RawCounts[,exclude])
Nano_RawCounts = Nano_RawCounts[ , !(colnames(Nano_RawCounts) %in% exclude)]
Nano_SampleInfo = Nano_SampleInfo[!(Nano_SampleInfo$sample_type=="FFPE"),] 

row.names(Nano_RawCounts) <- Nano_ExpressionMatrix[Nano_ExpressionMatrix$subtype=="TCGA" | Nano_ExpressionMatrix$subtype=="TME" | Nano_ExpressionMatrix$subtype=="Negative" |Nano_ExpressionMatrix$subtype=="Positive" |Nano_ExpressionMatrix$subtype=="Housekeeping" ,]$Probe.Name
Nano_SampleInfo$SampleNames <- colnames(Nano_RawCounts)


##################################################################################################################################
##################################################################  Exploratory  data analysis – raw counts #####################
#***** Colors for each cartridges
Color_Batches <- c('purple','orange','darkred','blue','chartreuse',
                   'darkgoldenrod4','tan2','darkgreen','red3','darkmagenta',
                   'deeppink','violet','navy','red','dodgerblue')

#***** box plot of raw data - Endogenous genes only
RawCounts_log <- log2(Nano_RawCounts[1:107 , ]+1) # Excluding 7 housekeeping genes and Nanostring spike-ins
par(mar = c(6.5,6.5,2.3,0), mgp = c(3.7 , 1 , 0))
boxplot(RawCounts_log, las = 1, cex.axis = 2, ylab = '' , xlab = '', cex.lab = 4,
        xaxt = 'n', yaxt = 'n', main = 'Unnormalized counts', cex.main = 3.5,
        outline = FALSE, names = FALSE, frame = FALSE,
        whisklty = 3, whisklwd = 1.5, staplelty = 1, notch = TRUE, boxlwd = 2,
        staplelwd = 0 , boxcol = Color_Batches[factor(Nano_SampleInfo$Cartridges)],
        border = Color_Batches[factor(Nano_SampleInfo$cartridge)] , col='gray87')
box(lwd = 7, bty = 'l')
axis(1, cex.axis=1, at = c(1, seq(20,166,20)), cex.axis = 2.5, lwd.ticks = 4, mgp = c(3.5,1.6,0))
axis(2, at = c(0, seq(3,15,3)), mgp = c(3.5,.9,0), lwd.ticks = 4, las = 1, cex.axis=3)
mtext(expression(paste('Samples', '(', 'n'[samples], '=', '162', ')')), 1, line = 4.5, cex = 2.5)
mtext(expression(paste(Log[2],' (raw counts)')), 2, line = 3.5, cex = 2.7)


#***** RLE plot - Figure - Unormalized
par(mar = c(6.5,6.5,2.3,0))
boxplot(RawCounts_log - rowMedians(RawCounts_log),
        main = '', xlab = '', ylab = '', xaxt = 'n', yaxt = 'n', ylim = c(-4.1,4.1),
        outline = FALSE, names = FALSE, frame = FALSE, whisklty = 3, whisklwd = 1.5, staplelty = 1, notch = TRUE, boxlwd = 2,
        staplelwd = 0 , boxcol = Color_Batches[factor(Nano_SampleInfo$cartridge)],
        border = Color_Batches[factor(Nano_SampleInfo$cartridge)], col = 'gray87')
box(lwd = 7, bty = 'l')
title('Unnormalized counts', line = -2, cex.main = 3.5)
Median_RawData <- apply(RawCounts_log - rowMedians(RawCounts_log), 2, median)
points(c(1:ncol(RawCounts_log)), Median_RawData, col = Color_Batches[factor(Nano_SampleInfo$cartridge)], pch = 19, cex = 1.2)
axis(2, mgp = c(3.5, .9 ,0), lwd.ticks=6, las=1, cex.axis=3)
mtext('RLE', 2, line = 3.5, cex = 3.5)
abline(h = 0, col = 'black', lwd = 5, lty = 2)
par(lwd = 3)
legend(160, 4.1, legend = c(1,2,3,'.','.','.', 13,14,15),
       col = c(Color_Batches[1:3], rep('white', 3), Color_Batches[13:15]),
       pch = 19, bty = 'n', cex = 1.4)
text(x = 162, y = 4.2 ,labels  = 'Cartridges', cex = 1.5)
rm(Median_RawData)

#####LONG 
counts = RawCounts_log - rowMedians(RawCounts_log)
counts = as.data.frame(t(counts))
counts$ID <- seq.int(nrow(counts))
counts$batchid = Nano_SampleInfo$cartridge

counts_long <- tidyr::gather(counts, gene, measurement, ABCB6:ZCCHC24, factor_key=TRUE)
counts_long$ID = as.factor(counts_long$ID)
counts_long$batchid = as.factor(counts_long$batchid)

unnormalized_counts_organoid = ggplot(counts_long, aes(x=ID, y=measurement, fill=batchid)) + 
    geom_boxplot(notch=TRUE, outlier.size = 0.5) +
    geom_hline(yintercept=0, size =1.5, alpha=0.7) +
    ggtitle("Unnormalized Counts Organoid Nanostring Genes") +
    xlab("Sample") + 
    ylab("Relative Log2 Expression") +
    scale_y_continuous(limits=c(-7,7) , breaks = c(-6,-3, 0,3,6))+
    theme_classic()  + 
    theme(axis.text.x = element_blank()) +
    theme(axis.text.y = element_text(colour="black",size = 13)) + 
    theme(plot.title = element_text(face="plain", colour="black", size=13,hjust = 0)) +
    theme(axis.title.x = element_text(colour="black", size =13)) +
    theme(axis.title.y = element_text(colour="black", size=13)) +
    theme(legend.position = "none")

ggsave("unnormalized_counts_organoid.svg", unnormalized_counts_organoid, width=6, height=3)

#***** Average plot
### Average of Nanostring positive spike-ins controls
Mean_NegativeControlProbes <- apply(Nano_RawCounts[115:122, ], 2, mean)
### Average of Nanostring positive spike-ins controls
Mean_PositiveControlProbes <- apply(Nano_RawCounts[123:128, ], 2, mean)
### Average of housekeeping genes
Mean_HousekeepingGenes <- apply(Nano_RawCounts[108:114, ], 2, mean)
### Library size
LibrarySize <- colSums(Nano_RawCounts [ 1:128, ])

#### Average plots -  Supplementary Figure 2
par(mar = c(6,7,0,0))
plot(log2(LibrarySize), ylim = c(0,22), bty = 'l', typ = 'n', ylab = '', xlab = '', xaxt = 'n', yaxt = 'n')
axis(1, cex.axis = 1, at = c(1, seq(20,166,20)), cex.axis = 2, lwd.ticks = 4, mgp = c(3.5,1.4,0))
axis(2, cex.axis = 1, cex.axis = 2, lwd.ticks = 4, mgp = c(3.5,1,0), las = 1)
mtext(expression(paste(Log [2], ' (raw counts)')), 2, line = 3.5, cex = 3)
mtext(expression(paste('Samples', ' (', 'n'[samples], '=', '21', ')')), 1, line = 4.5, cex = 2.5)
X <- c(0,6,18,30,42,53,65,77,89,101,113,125,137,143,155,167)
GradiantColors <- paste0('gray', seq(90,20, by = -5))
for(i in 1:15) rect(X[i],-5, X[i+1], 22, col = GradiantColors[i], lty = 0 )
points(log2(LibrarySize), col = alpha('darkgoldenrod1', .8), pch = 15, cex = 1.8, lwd = 1.5)
lines(smooth.spline(c(1:length(LibrarySize)), log2(LibrarySize), df = 5), col = 'darkgoldenrod1', lwd = 4)
points(log2(Mean_HousekeepingGenes) + 3, cex = 2, col = alpha('red', .6), pch = 19)
lines(smooth.spline(c(1:length(LibrarySize)), log2(Mean_HousekeepingGenes) + 3, df = 5), col = 'red', lwd = 4)
points(log2(Mean_PositiveControlProbes) - 1, col = alpha('cyan2', .8), pch = 18, cex = 2.5)
lines(smooth.spline(c(1:length(LibrarySize)), log2(Mean_PositiveControlProbes) - 1, df = 5), col = 'cyan1', lwd = 4)
points(log2(Mean_NegativeControlProbes), col = alpha('green2', .6), pch = 17, cex = 1.8)
lines(smooth.spline(c(1:length(LibrarySize)), log2(Mean_NegativeControlProbes), df = 5), col = 'green2', lwd = 4)
box(lwd = 5, bty = 'l')
rm(X, GradiantColors, Mean_NegativeControlProbes,
   Mean_PositiveControlProbes, Mean_HousekeepingGenes,
   LibrarySize)


#***** Log ratio between all pairs of duplicated samples
DuplicatedSamples <- tuplicate(Nano_SampleInfo$Patient.barcodes, 2)
length(DuplicatedSamples) 

LogRatio_TechRep_RawCounts <- vector()
for(i in 1:1){
  index <- Nano_SampleInfo$Patient.barcodes == DuplicatedSamples[i]
  RepData <- RawCounts_log [ , index]
  LogRatio <- as.data.frame(RepData[ , 1] - RepData[ , 2] )
  colnames(LogRatio) <- 'LogRatio'
  LogRatio$Replicates <- rep( i , 107)
  LogRatio_TechRep_RawCounts <- rbind(LogRatio_TechRep_RawCounts , LogRatio)
  rm(i, index, RepData, LogRatio)
}
nrow(LogRatio_TechRep_RawCounts)/107 # 17
LogRatio_TechRep_RawCounts$Datasets <- 'Unnormalized'




##################################################################################################################################
############################################### RUV-III normalization - using technical replicates and control genes #############

#***** Creating replicate matrix
length(Nano_SampleInfo$Patient.barcodes) 
length(unique(Nano_SampleInfo$Patient.barcodes)) 

ReplicateMatrix <- ruv::replicate.matrix(Nano_SampleInfo$Patient.barcodes)
dim(ReplicateMatrix) 

### Making sure that every row has got only one number
par(mfrow = c(2,1))
barplot(colSums(ReplicateMatrix))
barplot(rowSums(ReplicateMatrix))
par(mfrow = c(1,1))


#***** Finding control genes
### Step 1: Using all genes as a set of negative control genes
# Performing RUVIII
dataRUV <- t(log2(Nano_RawCounts[1:107, ] + 1))
RUVcorrected <- ruv::RUVIII(Y = dataRUV, M = ReplicateMatrix, ctl = c(1:107))
RUVcorrected <- t(RUVcorrected)

### Step 2: Selecting the most stable genes from step 1
LowVarGenes <- apply(RUVcorrected, 1, var)
ControlGenes <- which(LowVarGenes < .5)
length(ControlGenes) 

### Step3: Performing RUV-III using the ControlGenes set
RUVcorrected <- RUVIII(Y = dataRUV, M = ReplicateMatrix, ctl = ControlGenes, k = 7)
RUVcorrected <- t(RUVcorrected)
dim(RUVcorrected)
# We tried different numbers of k based on our positive controls####
all(colnames(RUVcorrected) == Nano_SampleInfo$SampleNames) ## TRUE


#***** RLE plots - Figure , RUV-III normalization
par(mar = c(6.5,6.5,2.3,0))
boxplot(RUVcorrected - rowMedians(RUVcorrected), main = '', xlab = '', ylab = '', xaxt = 'n', yaxt = 'n', ylim = c(-4.1,4.1),
        outline = FALSE, names = FALSE, frame = FALSE, whisklty = 3, whisklwd = 1.5, staplelty = 1, notch = TRUE, boxlwd = 2,
        staplelwd = 0 , boxcol = Color_Batches[factor(Nano_SampleInfo$cartridge)],
        border = Color_Batches[factor(Nano_SampleInfo$cartridge)], col = 'gray87')
box(lwd = 7, bty = 'l')
title('RUV-III normalized', line = -2, cex.main = 3.5)
Median_RUV <- apply(RUVcorrected - rowMedians(RUVcorrected), 2, median)
points(c(1:ncol(RUVcorrected)), Median_RUV, col = Color_Batches[factor(Nano_SampleInfo$cartridge)], pch = 19, cex = 1.2)
axis(1, cex.axis = 1, at = c(1, seq(20,166,20)), cex.axis = 2.5, lwd.ticks = 6,  mgp = c(3.5,1.6,0))
axis(2, mgp = c(3.5,.9,0), lwd.ticks = 6, las = 1, cex.axis = 3)
mtext(expression(paste('Samples','(', 'n'[samples], '=', '162', ')')),1 ,line = 5, cex = 3)
mtext('RLE', 2, line = 3.5, cex = 3.5)
abline(h = 0, col = 'black', lwd = 5, lty = 2)

#####LONG 
counts = RUVcorrected - rowMedians(RUVcorrected)
counts = as.data.frame(t(counts))
counts$ID <- seq.int(nrow(counts))
counts$batchid = Nano_SampleInfo$cartridge

counts_long <- tidyr::gather(counts, gene, measurement, ABCB6:ZCCHC24, factor_key=TRUE)
counts_long$ID = as.factor(counts_long$ID)
counts_long$batchid = as.factor(counts_long$batchid)

normalized_counts_organoid = ggplot(counts_long, aes(x=ID, y=measurement, fill=batchid)) + 
    geom_boxplot(notch=TRUE, outlier.size = 0.5) +
    geom_hline(yintercept=0, size =1.5, alpha=0.7) +
    ggtitle("RUV-III Normalized Counts Organoid Nanostring Genes") +
    xlab("Sample") + 
    ylab("Relative Log2 Expression") +
    scale_y_continuous(limits=c(-7,7) , breaks = c(-6,-3, 0,3,6))+
    theme_classic()  + 
    theme(axis.text.x = element_blank()) +
    theme(axis.text.y = element_text(colour="black",size = 13)) + 
    theme(plot.title = element_text(face="plain", colour="black", size=13,hjust = 0)) +
    theme(axis.title.x = element_text(colour="black", size =13)) +
    theme(axis.title.y = element_text(colour="black", size=13)) +
    theme(legend.position = "none")

ggsave("normalized_counts_organoid.svg", normalized_counts_organoid, width=6, height=3)

#***** Log DIFFERENCE between technical duplicated - per the paper
### Assessing the perfromance of RUV-III using 'leave out one duplicate'
DuplicatedSamples <- tuplicate(Nano_SampleInfo$Patient.barcodes, 2)
length(DuplicatedSamples) # 17
LogRatio_TechRep_RUVIII <- vector()
dataRUV <- t(log2(Nano_RawCounts[1:107, ] +1))

for(l in 1:length(DuplicatedSamples)){
  index <- Nano_SampleInfo$Patient.barcodes == DuplicatedSamples[l]
  info <- Nano_SampleInfo
  info$Patient.barcodes[index] <- c('Rep1', 'Rep2')
  X <- length(info$Patient.barcodes)
  Y <- length(unique(info$Patient.barcodes))
  
  ReplicateMatrix <- matrix(0, nrow = X, ncol = Y)
  row.names(ReplicateMatrix) <- info$Patient.barcodes
  colnames(ReplicateMatrix) <- unique(info$Patient.barcodes)
  for(i in 1:Y){
    n <- colnames(ReplicateMatrix)[i]
    sa <- which(row.names(ReplicateMatrix)==n)
    for(j in 1:length(sa)){
      ReplicateMatrix [sa[j] , i] <- 1
    }
  }
  RUVcorrected_Data <- ruv::RUVIII(dataRUV , ReplicateMatrix , ctl = ControlGenes, k = 2)
  RUVcorrected_Data <- t(RUVcorrected_Data)
  index <- which(index)
  LogRatio <- as.data.frame( (RUVcorrected_Data[ , index[1]] ) - (RUVcorrected_Data[ , index[2]]) )
  colnames(LogRatio) <- 'LogRatio'
  LogRatio$Replicates <- rep(l , 107)
  LogRatio_TechRep_RUVIII <- rbind(LogRatio_TechRep_RUVIII , LogRatio)
  rm(i, index, info, X, Y, LogRatio)
  
}
nrow(LogRatio_TechRep_RUVIII)/107
LogRatio_TechRep_RUVIII$Datasets <- 'RUV-III normalized'


#***** Technical Replicate Agreement plot for unnormalized, Nanostring Normalization and RUV-III (leave out one technical replicate)
### Figure 
TRAallNormalizations <- rbind(LogRatio_TechRep_RawCounts, LogRatio_TechRep_RUVIII)
TRAallNormalizations$Replicates <- as.factor(TRAallNormalizations$Replicates)
TRAallNormalizations$Datasets <- as.factor(TRAallNormalizations$Datasets)
TRAallNormalizations$Datasets  <- factor(TRAallNormalizations$Datasets , levels = c('Unnormalized','RUV-III normalized'))
ggplot(data = TRAallNormalizations) +
  geom_boxplot(aes(y = LogRatio, x = Replicates, fill = Datasets, color=Datasets), outlier.size = .5,
               position = position_dodge(width = .7),
               width = 1, alpha = 0.8, lwd = .7) +
  ylab('Log ratio')+ylim(c(-10,10)) +
  scale_color_manual(values = c('lightblue', 'royalblue', 'navy')) +
  scale_fill_manual(values = c('lightblue', 'royalblue', 'navy')) +
  theme_classic() +
  geom_hline(yintercept = 0, lty = 2, lwd = .6, col = 'red')+
  theme(axis.title = element_text(size = 25),
        axis.text.x = element_text(size = 20),
        axis.text.y = element_text(size = 20),
        axis.line = element_line(size = 1.5),
        legend.title = element_text(size = 20, face = c('italic', 'bold')),
        legend.text = element_text(size = 20),
        legend.position = "top", legend.direction = "horizontal")


#***** Log RATIO between technical duplicated - the paper incorrectly called the log difference the ratio 
### Assessing the perfromance of RUV-III using 'leave out one duplicate'
DuplicatedSamples <- tuplicate(Nano_SampleInfo$Patient.barcodes, 2)
length(DuplicatedSamples) # 17
LogRatio_TechRep_RUVIII <- vector()
dataRUV <- t(log2(Nano_RawCounts[1:107, ] +1))

for(l in 1:length(DuplicatedSamples)){
  index <- Nano_SampleInfo$Patient.barcodes == DuplicatedSamples[l]
  info <- Nano_SampleInfo
  info$Patient.barcodes[index] <- c('Rep1', 'Rep2')
  X <- length(info$Patient.barcodes)
  Y <- length(unique(info$Patient.barcodes))
  
  ReplicateMatrix <- matrix(0, nrow = X, ncol = Y)
  row.names(ReplicateMatrix) <- info$Patient.barcodes
  colnames(ReplicateMatrix) <- unique(info$Patient.barcodes)
  for(i in 1:Y){
    n <- colnames(ReplicateMatrix)[i]
    sa <- which(row.names(ReplicateMatrix)==n)
    for(j in 1:length(sa)){
      ReplicateMatrix [sa[j] , i] <- 1
    }
  }
  RUVcorrected_Data <- ruv::RUVIII(dataRUV , ReplicateMatrix , ctl = ControlGenes, k = 2)
  RUVcorrected_Data <- t(RUVcorrected_Data)
  index <- which(index)
  LogRatio <- as.data.frame( (RUVcorrected_Data[ , index[1]] ) / (RUVcorrected_Data[ , index[2]]))
  colnames(LogRatio) <- 'LogRatio'
  LogRatio$Replicates <- rep(l , 107)
  LogRatio_TechRep_RUVIII <- rbind(LogRatio_TechRep_RUVIII , LogRatio)
  rm(i, index, info, X, Y, LogRatio)
  
}
nrow(LogRatio_TechRep_RUVIII)/107
LogRatio_TechRep_RUVIII$Datasets <- 'RUV-III normalized'


#***** Technical Replicate Agreement plot for unnormalized, Nanostring Normalization and RUV-III (leave out one technical replicate)
### Figure 1 
TRAallNormalizations <- rbind(LogRatio_TechRep_RawCounts, LogRatio_TechRep_RUVIII)
TRAallNormalizations$Replicates <- as.factor(TRAallNormalizations$Replicates)
TRAallNormalizations$Datasets <- as.factor(TRAallNormalizations$Datasets)
TRAallNormalizations$Datasets  <- factor(TRAallNormalizations$Datasets , levels = c('Unnormalized','RUV-III normalized'))
ggplot(data = TRAallNormalizations) +
  geom_boxplot(aes(y = LogRatio, x = Replicates, fill = Datasets, color=Datasets), outlier.size = .5,
               position = position_dodge(width = .7),
               width = 1, alpha = 0.8, lwd = .7) +
  ylab('Log ratio')+ylim(c(-10,10)) +
  scale_color_manual(values = c('lightblue', 'royalblue', 'navy')) +
  scale_fill_manual(values = c('lightblue', 'royalblue', 'navy')) +
  theme_classic() +
  geom_hline(yintercept = 1, lty = 2, lwd = .6, col = 'red')+
  theme(axis.title = element_text(size = 25),
        axis.text.x = element_text(size = 20),
        axis.text.y = element_text(size = 20),
        axis.line = element_line(size = 1.5),
        legend.title = element_text(size = 20, face = c('italic', 'bold')),
        legend.text = element_text(size = 20),
        legend.position = "top", legend.direction = "horizontal")

############################################ FINAL NORMALIZATION ###################################################
length(Nano_SampleInfo$Patient.barcodes) 
length(unique(Nano_SampleInfo$Patient.barcodes)) 

ReplicateMatrix <- ruv::replicate.matrix(Nano_SampleInfo$Patient.barcodes)
dim(ReplicateMatrix) 
#***** Finding control genes
### Step 1: Using all genes as a set of negative control genes
# Performing RUVIII
dataRUV <- t(log2(Nano_RawCounts[1:107, ] +1))
RUVcorrected <- ruv::RUVIII(Y = dataRUV, M = ReplicateMatrix, ctl = c(1:107))
RUVcorrected <- t(RUVcorrected)

### Step 2: Selecting the most stable genes from step 1
LowVarGenes <- apply(RUVcorrected, 1, var)
ControlGenes <- which(LowVarGenes < .5)
length(ControlGenes) 


### Step3: Performing RUV-III using the ControlGenes set
RUVcorrected <- RUVIII(Y = dataRUV, M = ReplicateMatrix, ctl = ControlGenes, k = 7)
RUVcorrected <- t(RUVcorrected)
dim(RUVcorrected)
# We tried different numbers of k based on our positive controls
all(colnames(RUVcorrected) == Nano_SampleInfo$SampleNames) ## TRUE

RUVcorrected_all_organoid = RUVcorrected
```
#Heatmap
```{r}
#normalized together ffpe
common_nanostring = RUVcorrected_all_organoid
pheatmap(common_nanostring)

common_nanostring = t(common_nanostring)
common_nanostring = as.data.frame(common_nanostring)

names = Nano_SampleInfo
names = dplyr::select(names, c("Patient.barcodes","SampleNames"))

common_nanostring = tibble::rownames_to_column(common_nanostring, "sample_id")


normcancer_organoid = merge(common_nanostring, names, by.x="sample_id", by.y="SampleNames")
normcancer_organoid = normcancer_organoid[,-1]
colnames(normcancer_organoid)[which(names(normcancer_organoid) == "Patient.barcodes")] <- "sample_id"



normcancer_organoid %>% group_by(sample_id) %>% summarise_all(mean) %>% data.frame() -> normcancer_organoid
normcancer_organoid = tibble::column_to_rownames(normcancer_organoid, "sample_id")
pheatmap(normcancer_organoid)

colnames(normcancer_organoid) = gsub("\\.", "-", colnames(normcancer_organoid))


```
#Combo heatmap 
```{r}
combo_normcancer = rbind(normcancer_ffpe,normcancer_organoid)
combo_normcancer = tibble::rownames_to_column(combo_normcancer, "sample_id")


urlfile = "https://github.com/skubleny/Organoid-Cancer-Normal-Classification/raw/main/Data/combo_nanostring_no67.csv"
combo_nanostring_no67 = read.csv(urlfile)

subset = dplyr::select(combo_nanostring_no67, c("sample_id", "TME_subtype", "TCGA_subtype"))

combo_normcancer = merge(combo_normcancer,subset, by="sample_id",all=TRUE )

combo_normcancer$Diagnosis <- ifelse(grepl("N", combo_normcancer$sample, ignore.case = T), "Normal", "Cancer")
combo_normcancer$Tissue_Origin <- ifelse(grepl("O", combo_normcancer$sample, ignore.case = T), "Organoid", "FFPE")
```

#Heatmap annotation
```{r}
#Load additional packages
library(stringr)
library(RColorBrewer)
library(circlize)
```
```{r}
#Set up data
combo_normcancer_num = combo_normcancer[,c(1:108)]
combo_normcancer_num = tibble::column_to_rownames(combo_normcancer_num, "sample_id")

#Check if the rownames match up with the original dataframe
table(combo_normcancer$sample_id == rownames(combo_normcancer_num)) 

#Fix the strings
combo_normcancer$TCGA_subtype <- str_replace_all(combo_normcancer$TCGA_subtype, c("STAD_GS" = "GS", "STAD_CIN" = "CIN", "STAD_EBV" = "EBV", "STAD_MSI" = "MSI"))
combo_normcancer$TME_subtype <- str_replace_all(combo_normcancer$TME_subtype, c("High_cal" = "High", "Low_cal" = "Low"))

#Establish annotation data
annotate_col = dplyr::select(combo_normcancer, c("Diagnosis","Tissue_Origin", "TCGA_subtype", "TME_subtype"))
annotate_col$Diagnosis = as.factor(annotate_col$Diagnosis)
annotate_col$Tissue_Origin = as.factor(annotate_col$Tissue_Origin)
annotate_col$TCGA_subtype = as.factor(annotate_col$TCGA_subtype)
annotate_col$TME_subtype = as.factor(annotate_col$TME_subtype)
annotate_col = as.data.frame(annotate_col)
row.names(annotate_col) = combo_normcancer$patient_id
annotate_col = dplyr::select(annotate_col, c("Diagnosis", "Tissue_Origin" ,"TCGA_subtype", "TME_subtype"))
colnames(annotate_col) = c("Diagnosis", "Tissue Origin", "TCGA Subtype", "TME Subtype" )


#Assign annotation colours
ann_colors = list(
  Diagnosis = c('Cancer'="#B2182B","Normal"="#2B8CBE"),
  `Tissue Origin`  = c('FFPE'="#92C5DE","Organoid" = "#EF8A62"),
  `TCGA Subtype` = c('CIN'="#F39B7FFF", 'EBV'="#91D1C2FF", "GS"= "#4393C3", "MSI" = "#E64B35FF"),
  `TME Subtype` = c('High'="#925E9FFF", 'Low'="#EFC000FF"))

#Continuous colour gradient with appropriate breaks
cols = rev(brewer.pal(9, "RdBu"))
paletteLength=1000
myBreaks <- c(seq(min(combo_normcancer_num), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(combo_normcancer_num)/paletteLength, max(combo_normcancer_num), length.out=floor(paletteLength/2)))

#Gradient for legend
col_fun = colorRamp2(c(-21.52954, -0.05038076,  11.10719), c("#2166AC", "#F7F7F7", "#B2182B"))

#Test
pheatmap(t(combo_normcancer_num), color = colorRampPalette(cols)(1000), show_colnames = TRUE, show_rownames = FALSE, annotation_col = annotate_col,annotation_colors = ann_colors, treeheight_row = 20, treeheight_col = 20, legend_breaks = c(-20,-10, 0, 10, max(combo_normcancer_num)), legend_labels = c("-20", "-10", "0", "10", "Probability"))
lgd = Legend(col_fun = col_fun, at = c(-20,-10, 0, 10), title = "Gene Expression", legend_height = unit(2, "cm"))

#Generate heatmap
heatmap = pheatmap(t(combo_normcancer_num), color = colorRampPalette(cols)(1000),breaks = myBreaks,legend = F, show_colnames = TRUE, show_rownames = FALSE, annotation_col = annotate_col,annotation_colors = ann_colors,cellwidth = 10, treeheight_row = 20, treeheight_col = 20)
draw(heatmap)
draw(lgd, x = unit(27.5, "cm"), y = unit(16, "cm"), just = c("right", "bottom"))

#Save svg (Note: the gene expression legend appears different in viewer compared to saved file)
svg(filename="heatmap_ffpe_organoid_new.svg", width=12, height=6)
draw(heatmap)
draw(lgd, x = unit(27.9, "cm"), y = unit(1, "cm"), just = c("right", "bottom"))
dev.off()
#Save png
png(filename="heatmap_ffpe_organoid_new.png", width=12, height=6,units="in", res = 300)
draw(heatmap)
draw(lgd, x = unit(27.9, "cm"), y = unit(1, "cm"), just = c("right", "bottom"))
dev.off()


```

#Load gene expression data
Gene expression data generated with same method as https://github.com/skubleny/Integrated-Molecular-Classification-GC

#Download cancer ACRG data
```{r}
# Create a temporary file and directory
zip_path <- tempfile(fileext = ".zip")
unzip_dir <- tempdir()

# Download the zip file
download.file("https://github.com/skubleny/Organoid-Cancer-Normal-Classification/raw/main/Data/log_ACRG.csv.zip",
              destfile = zip_path, mode = "wb")

# Unzip it
unzip(zip_path, exdir = unzip_dir)
unzipped_files <- list.files(unzip_dir, full.names = TRUE)
print(unzipped_files)
target_file <- unzipped_files[grepl("log_ACRG.*\\.csv$", basename(unzipped_files), ignore.case = TRUE)]


log_ACRG <- read.csv(target_file, row.names = 1)

unlink(unzip_dir, recursive = TRUE)  # folder
```
#Download normal ACRG data
```{r}
# Create a temporary file and directory
zip_path <- tempfile(fileext = ".zip")
unzip_dir <- tempdir()

# Download the zip file
download.file("https://github.com/skubleny/Organoid-Cancer-Normal-Classification/raw/main/Data/log_norm_ACRG.csv.zip",
              destfile = zip_path, mode = "wb")

# Unzip it
unzip(zip_path, exdir = unzip_dir)
unzipped_files <- list.files(unzip_dir, full.names = TRUE)
print(unzipped_files)
target_file <- unzipped_files[grepl("log_norm_ACRG.*\\.csv$", basename(unzipped_files), ignore.case = TRUE)]

log_norm_ACRG <- read.csv(target_file, row.names = 1)

unlink(unzip_dir, recursive = TRUE)  # folder

```
#Commongenes
From Integrated GC
```{r}
urlfile<-'https://raw.githubusercontent.com/skubleny/Organoid-Cancer-Normal-Classification/main/Data/commongenes.csv'

commongenes <-read.csv(urlfile, row.names = 1)

```
#ACRG data combo
```{r}
data_log_norm_ACRG <- subset(log_norm_ACRG, rownames(log_norm_ACRG) %in% as.matrix(commongenes))
data_log_norm_ACRG = t(data_log_norm_ACRG)

normal = as.data.frame(data_log_norm_ACRG)
normal$type = "Normal"
normal= tibble::rownames_to_column(normal, "patient_id")
normal = dplyr::select(normal, c("patient_id", "type"))

log_ACRG_cancer <- subset(log_ACRG, rownames(log_ACRG) %in% as.matrix(commongenes))
log_ACRG_cancer = t(log_ACRG_cancer)

cancer = as.data.frame(log_ACRG_cancer)
cancer$type = "Cancer"
cancer= tibble::rownames_to_column(cancer, "patient_id")
cancer = dplyr::select(cancer, c("patient_id", "type"))

type = rbind(normal,cancer)
```
#QN cancer and normal
```{r}

combo_dist= rbind(data_log_norm_ACRG,log_ACRG_cancer)
combo_dist = as.matrix(combo_dist)
combo_dist = t(combo_dist)

colramp = colorRampPalette(c(3,"white",2))(20)
plot(density(combo_dist[,1]),col=colramp[1],lwd=1,ylim=c(0,.40))
for(i in 2:400){lines(density(combo_dist[,i]),lwd=1,col=colramp[i])}

```
```{r}
#Quantile normalize
norm_combo_dist = normalize.quantiles(as.matrix(combo_dist))
```
```{r}
#Check normalize data plot
plot(density(norm_combo_dist[,1]),col=colramp[1],lwd=1,ylim=c(0,.40))
for(i in 2:400){lines(density(norm_combo_dist[,i]),lwd=1,col=colramp[i])}
```
#Assigns column and rown names to normalized data
```{r}
x = colnames(combo_dist)
colnames(norm_combo_dist) = x
y = row.names(combo_dist)
row.names(norm_combo_dist) = y
```

#Reduce to cancer genes only 
```{r}
TCGA = Nano_ExpressionMatrix[Nano_ExpressionMatrix$subtype=="TCGA",]$Probe.Name
TME = Nano_ExpressionMatrix[Nano_ExpressionMatrix$subtype=="TME",]$Probe.Name
genelist = c(TCGA, TME)
genelist = na.omit(genelist)
genelist = as.matrix(genelist)

#ACRG common distribution with type assigned
common_dist <- subset(norm_combo_dist, rownames(norm_combo_dist) %in% as.matrix(genelist))
common_dist = t(common_dist)

common_dist = as.data.frame(common_dist)
common_dist = tibble::rownames_to_column(common_dist, "patient_id")

common_dist = merge(common_dist,type, by="patient_id")
common_dist = common_dist[c(1,109, 2:108)]
combined_edata = tibble::column_to_rownames(common_dist, "patient_id")
```

